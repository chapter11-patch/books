= F# の文法

//lead{
本章では、本書を読むために必要な F# の文法について、簡単に解説を行います。
//}

== 簡単な演算とコメント

まずは、簡単な演算から行ってみましょう。

//emlist{
(1 + 2) * 3 // equal 9
//}

スラッシュを続けて二つ書いた場合は、それ以降が行コメントとして解釈されます。
期待する結果を得られたなら、その環境は期待通り動作していることを意味します。

別の例を試してみましょう。

//emlist{
2 * 3.0 // コンパイルエラー!!
//}

F# は強い静的型付き言語なので、上記コードはコンパイルエラーになります。
仮にこのコードを実行させたい場合、どちらかの値を明示的に型変換する必要があります。
今回は、整数型の結果を取得することにしましょう。

//emlist{
2 * (int 3.0) // equal 6
//}

今度は実行できました。

== 値束縛

様々な計算を行うにあたり、計算結果をどこかに記憶しておけると便利ですね。
F# では、 @<kw>{let} キーワードを使って値と識別子を関連付けることができます。
これを、値束縛と呼びます。

//emlist{
let 識別子 : 型名 = 式
//}

式の計算結果により型の推論が可能なため、型の記述を省略することができます。
本書では理解のための補助として型を明示する時以外は、型の記述を省略します。

では、演算結果を束縛してみましょう。

//emlist{
let x = (1 + 2) * 3 // x equal 9
//}

識別子と式を別々の行に分けることもできます。

//emlist{
let y =
  1 + 2 * 3 - 4
//}

また、ある識別子に束縛する式内でも束縛が可能です。

//emlist{
let z =
  let x = 1
  let y = 2 * 3
  x + y - 4
//}

この場合、内部の @<kw>{let} キーワードと式本体は同じインデントにする必要があります。
内部で定義した x と y には、z の式本体以外からアクセスすることはできません。

既に値が束縛されている識別子を式に組み込むこともできます。

//emlist{
let x = 1
let y = 2 * 3
let z = x + y - 4
//}

単純に識別子、と記述すると混乱してしまう可能性があるため、以降では束縛により値と関連付けられた識別子を変数と呼ぶことにします。
